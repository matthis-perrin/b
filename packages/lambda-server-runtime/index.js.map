{"version":3,"file":"index.js","mappings":"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","sources":["webpack://b/external node-commonjs \"node:crypto\"","webpack://b/external node-commonjs \"node:fs\"","webpack://b/external node-commonjs \"node:http\"","webpack://b/./src/type_utils.ts","webpack://b/./src/lambda-server-runtime/runtime.ts"],"sourcesContent":["const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:crypto\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:fs\");","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_createRequire(import.meta.url)(\"node:http\");","function notUndefined<T>(val: T | undefined): val is T {\n  return val !== undefined;\n}\n\nexport function isString(val: unknown): val is string {\n  return typeof val === 'string';\n}\n\nexport function isNumber(val: unknown): val is number {\n  return typeof val === 'number';\n}\n\nexport function iterNumberEnum<T extends Record<string, string | number>>(e: T): T[keyof T][] {\n  return Object.values(e).filter(isNumber) as unknown as T[keyof T][];\n}\n\nexport function iterStringEnum<T extends Record<string, string>>(e: T): T[keyof T][] {\n  return Object.values(e).filter(isString) as unknown as T[keyof T][];\n}\n\nexport function removeUndefined<T>(arr: (T | undefined)[]): T[] {\n  return arr.filter(notUndefined);\n}\n\nexport function removeUndefinedOrNullProps<T extends Record<string, unknown>>(obj: T): {} {\n  return Object.fromEntries(\n    Object.entries(obj).filter(e => e[1] !== undefined && e[1] !== null)\n  ) as T;\n}\n\nexport function neverHappens(value: never, errorMessage?: string): never {\n  throw new Error(errorMessage);\n}\n\nexport type AnyInterface<T> = {[K in keyof T]: unknown};\n\nexport function asMap(value: unknown): Record<string, unknown> | undefined;\nexport function asMap(\n  value: unknown,\n  defaultValue: Record<string, unknown>\n): Record<string, unknown>;\nexport function asMap(\n  value: unknown,\n  defaultValue?: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n    ? (value as Record<string, unknown>)\n    : defaultValue;\n}\nexport function asMapOrThrow(value: unknown): Record<string, unknown> {\n  const valueAsMap = asMap(value);\n  if (valueAsMap === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` is not a map`);\n  }\n  return valueAsMap;\n}\n\nexport function asJson(value: string): Record<string, unknown> | undefined;\nexport function asJson(\n  value: string,\n  defaultValue: Record<string, unknown>\n): Record<string, unknown>;\nexport function asJson(\n  value: string,\n  defaultValue?: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  try {\n    const json = JSON.parse(value);\n    const res = asMap(json);\n    return res ?? defaultValue;\n  } catch {\n    return defaultValue;\n  }\n}\nexport function asJsonOrThrow(value: string): Record<string, unknown> {\n  const valueAsJson = asJson(value);\n  if (valueAsJson === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` is not a valid JSON string of a map`);\n  }\n  return valueAsJson;\n}\n\nexport function asJsonString(value: unknown): Record<string, unknown> | undefined;\nexport function asJsonString(\n  value: unknown,\n  defaultValue: Record<string, unknown>\n): Record<string, unknown>;\nexport function asJsonString(\n  value: unknown,\n  defaultValue?: Record<string, unknown>\n): Record<string, unknown> | undefined {\n  const str = asString(value);\n  return str === undefined\n    ? defaultValue\n    : defaultValue === undefined\n      ? asJson(str)\n      : asJson(str, defaultValue);\n}\nexport function asJsonStringOrThrow(value: unknown): Record<string, unknown> {\n  return asJsonOrThrow(asStringOrThrow(value));\n}\n\nexport function asString<T extends string = string>(value: unknown): T | undefined;\nexport function asString<T extends string = string>(value: unknown, defaultValue: string): T;\nexport function asString<T extends string = string>(\n  value: unknown,\n  defaultValue?: string\n): T | undefined {\n  return (typeof value === 'string' ? value : defaultValue) as T;\n}\nexport function asStringOrThrow<T extends string = string>(value: unknown): T {\n  const valueAsString = asString<T>(value);\n  if (valueAsString === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` is not a string`);\n  }\n  return valueAsString;\n}\n\nexport function asStringEnum<T extends Record<string, string>>(\n  value: unknown,\n  enu: T\n): T[keyof T] | undefined;\nexport function asStringEnum<T extends Record<string, string>>(\n  value: unknown,\n  enu: T,\n  defaultValue: T[keyof T]\n): T[keyof T];\nexport function asStringEnum<T extends Record<string, string>>(\n  value: unknown,\n  enu: T,\n  defaultValue?: T[keyof T]\n): T[keyof T] | undefined {\n  return (\n    typeof value === 'string' && Object.values(enu).includes(value as T[keyof T])\n      ? value\n      : defaultValue\n  ) as T[keyof T];\n}\nexport function asStringEnumOrThrow<T extends Record<string, string>>(\n  value: unknown,\n  enu: T\n): T[keyof T] {\n  const valueAsString = asStringEnum<T>(value, enu);\n  if (valueAsString === undefined) {\n    throw new Error(\n      `Invalid value: \\`${value}\\` is not a string or not one of ${JSON.stringify(\n        Object.values(enu)\n      )}`\n    );\n  }\n  return valueAsString;\n}\n\nexport function asArray<T = unknown>(value: unknown): T[] | undefined;\nexport function asArray<T = unknown>(value: unknown, defaultValue: unknown[]): T[];\nexport function asArray<T = unknown>(value: unknown, defaultValue?: unknown[]): T[] | undefined {\n  return (Array.isArray(value) ? value : defaultValue) as T[];\n}\nexport function asArrayOrThrow<T = unknown>(value: unknown): T[] {\n  if (!Array.isArray(value)) {\n    throw new Error(`Invalid value: \\`${value}\\` is not an array`);\n  }\n  return value as T[];\n}\n\nexport function asStringArray<T extends string = string>(value: unknown): T[] | undefined;\nexport function asStringArray<T extends string = string>(\n  value: unknown,\n  defaultValue: string[]\n): T[];\nexport function asStringArray<T extends string = string>(\n  value: unknown,\n  defaultValue?: string[]\n): T[] | undefined {\n  const arr = asArray(value);\n  if (arr === undefined) {\n    return defaultValue as T[];\n  }\n  return removeUndefined(arr.map(s => asString<T>(s)));\n}\n\nexport function asStringArrayOrThrow<T extends string = string>(value: unknown): T[] {\n  const arr = asArrayOrThrow(value);\n  return arr.map(s => asStringOrThrow<T>(s));\n}\n\nexport function asMapArray(value: unknown): Record<string, unknown>[] | undefined;\nexport function asMapArray(\n  value: unknown,\n  defaultValue: Record<string, unknown>[]\n): Record<string, unknown>[];\nexport function asMapArray(\n  value: unknown,\n  defaultValue?: Record<string, unknown>[]\n): Record<string, unknown>[] | undefined {\n  const arr = asArray(value);\n  if (arr === undefined) {\n    return defaultValue;\n  }\n  return removeUndefined(arr.map(s => asMap(s)));\n}\nexport function asMapArrayOrThrow(value: unknown): Record<string, unknown>[] {\n  const arr = asArrayOrThrow(value);\n  return arr.map(s => asMapOrThrow(s));\n}\n\nexport function asNumber<T extends number = number>(value: unknown): T | undefined;\nexport function asNumber<T extends number = number>(value: unknown, defaultValue: number): T;\nexport function asNumber<T extends number = number>(\n  value: unknown,\n  defaultValue?: number\n): T | undefined {\n  if (typeof value === 'number') {\n    return (!isNaN(value) ? value : defaultValue) as T;\n  }\n  if (typeof value === 'string') {\n    try {\n      const parsedValue = parseFloat(value);\n      return (!isNaN(parsedValue) ? parsedValue : defaultValue) as T;\n    } catch {\n      return defaultValue as T;\n    }\n  }\n  return defaultValue as T;\n}\nexport function asNumberOrThrow<T extends number = number>(value: unknown): T {\n  const valueAsNumber = asNumber(value);\n  if (valueAsNumber === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` is not a number`);\n  }\n  return valueAsNumber as T;\n}\n\nexport function asBoolean(value: unknown): boolean | undefined;\nexport function asBoolean(value: unknown, defaultValue: boolean): boolean;\nexport function asBoolean(value: unknown, defaultValue?: boolean): boolean | undefined {\n  if (typeof value === 'boolean') {\n    return value;\n  }\n  if (typeof value === 'number') {\n    return !isNaN(value) ? value !== 0 : false;\n  }\n  if (typeof value === 'string') {\n    if (value === '0' || value === 'false') {\n      return false;\n    } else if (value === '1' || value === 'true') {\n      return true;\n    }\n    return defaultValue;\n  }\n  return defaultValue;\n}\n\nexport function asBooleanOrThrow(value: unknown): boolean {\n  const valueAsBoolean = asBoolean(value);\n  if (valueAsBoolean === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` is not a boolean`);\n  }\n  return valueAsBoolean;\n}\n\nconst TIMESTAMP_REGEX = /^[0-9]{1,15}$/u;\nexport function asDate(value: unknown): Date | undefined;\nexport function asDate(value: unknown, defaultValue: Date): Date;\nexport function asDate(value: unknown, defaultValue?: Date): Date | undefined {\n  const date =\n    value instanceof Date\n      ? value\n      : new Date(\n          typeof value === 'string' && TIMESTAMP_REGEX.test(value)\n            ? parseFloat(value)\n            : String(value)\n        );\n  return isNaN(date.getTime()) ? defaultValue : date;\n}\n\nexport function asDateOrThrow(value: unknown): Date {\n  const valueAsDate = asDate(value);\n  if (valueAsDate === undefined) {\n    throw new Error(`Invalid value: \\`${value}\\` cannot be parsed as a Date`);\n  }\n  return valueAsDate;\n}\n\n// export function asDate(value: unknown): Date | undefined;\n// export function asDate(value: unknown, defaultValue: Date): Date;\n// export function asDate(value: unknown, defaultValue?: Date): Date | undefined {\n//   if (typeof value === 'number') {\n//     return new Date(value);\n//   }\n//   return value instanceof Date ? value : defaultValue;\n// }\n\nexport function isNull<T>(val: T | null): val is null {\n  return val === null;\n}\n\nexport function asError(err: unknown): Error {\n  return err instanceof Error ? err : new Error(typeof err === 'string' ? err : String(err));\n}\n\nexport function errorAsString(err: unknown): string {\n  const errorMap = asMap(err);\n  if (errorMap === undefined) {\n    return asString(err) ?? String(err);\n  }\n\n  const errorMessage = asString(errorMap['message']);\n  if (errorMessage === undefined) {\n    return String(err);\n  }\n  return errorMessage;\n}\n\nexport function errorAndStackAsString(err: unknown): string {\n  const errorMap = asMap(err);\n  if (errorMap === undefined) {\n    return asString(err) ?? String(err);\n  }\n\n  const stack = asString(errorMap['stack']);\n  if (stack === undefined) {\n    return String(err);\n  }\n  return stack;\n}\n\nexport function asConstantOrThrow<T>(value: unknown, expected: T): T {\n  if (value !== expected) {\n    throw new Error(`Invalid value: \\`${value}\\`, expected \\`${expected}\\``);\n  }\n  return value as T;\n}\n\n// export function asParsedJson<T>(json: string): T {\n//   try {\n//     return JSON.parse(json) as T;\n//   } catch {\n//     const defaultValue = {};\n//     return defaultValue as T;\n//   }\n// }\nexport function parseJson(\n  json: string\n): {res: unknown; err: undefined} | {res: undefined; err: unknown} {\n  try {\n    return {res: JSON.parse(json), err: undefined};\n  } catch (err: unknown) {\n    return {err, res: undefined};\n  }\n}\nexport type Brand<Type, Name> = Type & {__brand: Name};\nexport type StringBrand = string & {__brand: string};\nexport type NumberBrand = number & {__brand: number};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AnyBrand = (string | number) & {__brand: any};\n\nexport type Untrusted<T> = T extends\n  | Function\n  | Date\n  | boolean\n  | number\n  | string\n  | undefined\n  | null\n  | unknown[]\n  ? unknown\n  : {[P in keyof T]?: Untrusted<T[P]>};\n\nexport type DeepPartial<T> = T extends\n  | Function\n  | Date\n  | boolean\n  | number\n  | string\n  | undefined\n  | null\n  | unknown[]\n  ? T\n  : {[P in keyof T]?: DeepPartial<T[P]>};\n\nexport type MapInterface<I, Type> = {[Key in keyof I]: Type};\n// Get all the keys of a type including the optional attributes\ntype NonHomomorphicKeys<T> = ({[P in keyof T]: P} & None)[keyof T];\nexport type MapInterfaceStrict<I, Type> = {[Key in NonHomomorphicKeys<I>]: Type};\n\ntype KeysOfType<T, Type> = {[Key in keyof T]: T[Key] extends Type ? Key : never}[keyof T];\nexport type RestrictInterface<T, Type> = Pick<T, KeysOfType<T, Type>>;\n\ninterface RecursiveArray<T> extends Array<T | RecursiveArray<T>> {}\nexport type NestedArray<T> = (T | RecursiveArray<T>)[];\n\n// Type for an empty object (ie: {})\nexport type None = Record<string, never>;\n\nexport type NonEmptyArray<T> = [T, ...T[]];\nexport function isNonEmptyArray<T>(val: T[]): val is NonEmptyArray<T> {\n  return val.length > 0;\n}\nexport function nonEmptyArray<T>(val: T[]): NonEmptyArray<T> | undefined {\n  return val.length === 0 ? undefined : (val as NonEmptyArray<T>);\n}\n\nexport type AddPrefix<T, P extends string> = {\n  [K in keyof T as K extends string ? `${P}${K}` : never]: T[K];\n};\nexport function addPrefix<T extends Record<string, unknown>, Prefix extends string>(\n  attr: T,\n  prefix: Prefix\n): AddPrefix<T, Prefix> {\n  return Object.fromEntries(\n    Object.entries(attr).map(([key, value]) => [`${prefix}${key}`, value])\n  ) as AddPrefix<T, Prefix>;\n}\n\nexport type WithNull<T> = {\n  [Key in keyof T]: T[Key] extends Exclude<T[Key], undefined> ? T[Key] : T[Key] | null;\n};\ntype Id<T> = T;\nexport type Flatten<T> = Id<{[k in keyof T]: T[k]}>;\n\nexport type Defined<T> = Exclude<T, undefined>;\n","import {randomUUID} from 'node:crypto';\nimport {appendFileSync, writeFileSync} from 'node:fs';\nimport {createServer, IncomingMessage, ServerResponse} from 'node:http';\n\nimport {asMap, errorAndStackAsString} from '@src/type_utils';\nimport {LambdaServerEvent} from '@src/webpack/plugins/lambda_server_plugin';\n\n//\n// ENV VARIABLES LOADING\n//\n\n// eslint-disable-next-line n/no-process-env\nconst {PORT, RUNTIME_LOG_FILE, APP_LOG_FILE, HANDLER_PATH, TIMEOUT_MS} = process.env;\n\nconst port = parseFloat(PORT ?? '');\nif (isNaN(port)) {\n  runtimeLog({event: 'error', err: `Invalid process.env.PORT: ${PORT}`, path: '', method: ''});\n  // eslint-disable-next-line n/no-process-exit\n  process.exit(0);\n}\n\nconst timeoutMs = parseFloat(TIMEOUT_MS ?? '');\nif (isNaN(timeoutMs)) {\n  runtimeLog({\n    event: 'error',\n    err: `Invalid process.env.TIMEOUT_MS: ${TIMEOUT_MS}`,\n    path: '',\n    method: '',\n  });\n  // eslint-disable-next-line n/no-process-exit\n  process.exit(0);\n}\n\nif (HANDLER_PATH === undefined) {\n  runtimeLog({event: 'error', err: `Missing process.env.HANDLER_PATH`, path: '', method: ''});\n  // eslint-disable-next-line n/no-process-exit\n  process.exit(0);\n}\n\n//\n// LOGGING FUNCTIONS\n//\n\nfunction appLog(\n  appendFileSync: (file: string, content: string) => void,\n  log: string | string[]\n): void {\n  const logs = Array.isArray(log) ? log : [log];\n  if (APP_LOG_FILE === undefined || logs.length === 0) {\n    return;\n  }\n  appendFileSync(APP_LOG_FILE, logs.map(log => `[${new Date().toISOString()}] ${log}\\n`).join(''));\n}\n\nfunction runtimeLog(event: LambdaServerEvent): void {\n  if (RUNTIME_LOG_FILE === undefined) {\n    return;\n  }\n  if (event.event === 'error') {\n    logger(event.err);\n  }\n  appendFileSync(RUNTIME_LOG_FILE, `${JSON.stringify({t: new Date().toISOString(), ...event})}\\n`);\n}\n\n// Clear all previous logs\nif (APP_LOG_FILE !== undefined) {\n  writeFileSync(APP_LOG_FILE, '');\n}\nif (RUNTIME_LOG_FILE !== undefined) {\n  writeFileSync(RUNTIME_LOG_FILE, '');\n}\n\n//\n// HANDLER LOADING\n//\n\nconst logger = appLog.bind(null, appendFileSync);\nfunction serialize(val: unknown): string {\n  return val instanceof Error\n    ? errorAndStackAsString(val)\n    : typeof val === 'string'\n      ? val\n      : JSON.stringify(val);\n}\nconsole.log = (...args: unknown[]) => logger(args.map(serialize));\nconsole.error = (...args: unknown[]) => logger(args.map(serialize));\n\nlet handler: Function | undefined;\n// eslint-disable-next-line import/dynamic-import-chunkname\nimport(/* webpackIgnore: true */ HANDLER_PATH)\n  .then(imported => {\n    const importedHandler = asMap(imported)?.['handler'];\n    if (typeof importedHandler !== 'function') {\n      runtimeLog({\n        event: 'error',\n        err: `Lambda is not exporting a \"handler\" function`,\n        path: '',\n        method: '',\n      });\n      // eslint-disable-next-line n/no-process-exit\n      process.exit(0);\n    }\n    handler = importedHandler;\n  })\n  .catch((err: unknown) => {\n    runtimeLog({\n      event: 'error',\n      err: `Failure to load lambda handler: ${errorAndStackAsString(err)}`,\n      path: '',\n      method: '',\n    });\n    // eslint-disable-next-line n/no-process-exit\n    process.exit(0);\n  });\n\n//\n// LAMBDA SERVER\n//\n\nlet currentRes: ServerResponse | undefined;\nfunction globalError(err: unknown): void {\n  runtimeLog({event: 'error', err: String(err), path: '', method: ''});\n  if (currentRes) {\n    currentRes.statusCode = 500;\n    currentRes.end();\n    currentRes = undefined;\n  }\n}\n\nconst server = createServer((req: IncomingMessage, res: ServerResponse) => {\n  currentRes = res;\n  const url = req.url ?? '';\n\n  if (url.startsWith('/favicon')) {\n    res.end();\n    currentRes = undefined;\n    return;\n  }\n\n  const method = req.method ?? '';\n\n  const internalError = (err: string): void => {\n    runtimeLog({event: 'error', err, path: url, method});\n    res.statusCode = 500;\n    res.end();\n    currentRes = undefined;\n  };\n\n  try {\n    // Parse body\n    let body = '';\n    req.on('data', chunk => {\n      body += chunk;\n    });\n\n    // Parse URL\n    const parsedUrl = new URL(`http://localhost${url}`);\n    const rawQueryString = parsedUrl.search.slice(1);\n    const queryStringParameters = Object.fromEntries([\n      ...new URLSearchParams(decodeURIComponent(rawQueryString)).entries(),\n    ]);\n\n    const sendRes = (\n      body: string | Buffer,\n      duration: number,\n      // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n      statusCode = 200,\n      headers: Record<string, string> = {}\n    ): void => {\n      runtimeLog({\n        event: 'response',\n        path: url,\n        method,\n        statusCode,\n        duration,\n        headers,\n        bodyLength: body.length,\n      });\n      res.statusCode = statusCode;\n      for (const [headerName, headerValue] of Object.entries(headers)) {\n        res.setHeader(headerName, headerValue);\n      }\n      res.write(body);\n      res.end();\n      currentRes = undefined;\n    };\n\n    req.on('end', () => {\n      // Log the request\n      runtimeLog({event: 'request', path: url, method, bodyLength: body.length});\n\n      // Create the lambda event\n      const event = {\n        version: '2.0',\n        routeKey: '$default',\n        rawPath: parsedUrl.pathname,\n        rawQueryString,\n        headers: req.headers,\n        queryStringParameters,\n        requestContext: {\n          accountId: 'anonymous',\n          // apiId: 'rqez6mmiihukf4yvq2l7rrq2340xpkvp',\n          // domainName: 'rqez6mmiihukf4yvq2l7rrq2340xpkvp.lambda-url.eu-west-3.on.aws',\n          // domainPrefix: 'rqez6mmiihukf4yvq2l7rrq2340xpkvp',\n          http: {\n            method,\n            path: parsedUrl.pathname,\n            // protocol: 'HTTP/1.1',\n            // sourceIp: '88.138.164.86',\n            userAgent: req.headers['user-agent'],\n          },\n          requestId: randomUUID(),\n          routeKey: '$default',\n          stage: '$default',\n          timeEpoch: Date.now(),\n        },\n        body,\n        isBase64Encoded: false,\n      };\n\n      // Run the handler\n      if (!handler) {\n        // eslint-disable-next-line @typescript-eslint/no-magic-numbers\n        sendRes('Lambda handler not found', 0, 404);\n        return;\n      }\n      const startTs = Date.now();\n      try {\n        const context = {\n          getRemainingTimeInMillis: () => {\n            return timeoutMs - (Date.now() - startTs);\n          },\n        };\n        Promise.resolve(handler(event, context))\n          .then(handlerRes => {\n            const duration = Date.now() - startTs;\n            try {\n              if (handlerRes === undefined) {\n                return internalError(`Invalid response: ${JSON.stringify(handlerRes)}`);\n              }\n              res.setHeader('Content-Type', 'application/json');\n              if (\n                typeof handlerRes === 'object' &&\n                handlerRes !== null &&\n                !Array.isArray(handlerRes)\n              ) {\n                const {body, headers, statusCode, isBase64Encoded} = handlerRes;\n                if (!('statusCode' in handlerRes)) {\n                  return sendRes(JSON.stringify(handlerRes), duration);\n                } else if (typeof statusCode !== 'number') {\n                  return internalError(`statusCode ${JSON.stringify(statusCode)} is not a number`);\n                }\n                const resBody =\n                  typeof body === 'string'\n                    ? typeof isBase64Encoded === 'boolean' && isBase64Encoded\n                      ? Buffer.from(body, 'base64')\n                      : body\n                    : JSON.stringify(body);\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                return sendRes(resBody, duration, statusCode, headers);\n              } else if (typeof handlerRes === 'string') {\n                return sendRes(handlerRes, duration);\n              }\n              return sendRes(JSON.stringify(handlerRes), duration);\n            } catch (err: unknown) {\n              internalError(errorAndStackAsString(err));\n            }\n          })\n          .catch((err: unknown) => {\n            internalError(errorAndStackAsString(err));\n          });\n      } catch (err: unknown) {\n        internalError(errorAndStackAsString(err));\n      }\n    });\n  } catch (err: unknown) {\n    internalError(String(err));\n  }\n})\n  .listen(PORT)\n  .on('error', err => {\n    globalError(err);\n  })\n  .on('listening', () => {\n    runtimeLog({event: 'start', port});\n  });\n\nfunction cleanup(): void {\n  server.close();\n}\n\nprocess.on('SIGINT', () => cleanup());\nprocess.on('SIGTERM', () => cleanup());\nprocess.on('uncaughtException', err => {\n  globalError(err);\n  cleanup();\n});\nprocess.on('unhandledRejection', err => {\n  globalError(err);\n  cleanup();\n});\n"],"names":["__WEBPACK_EXTERNAL_createRequire","url","asMap","value","defaultValue","Array","isArray","asString","errorAndStackAsString","err","errorMap","undefined","String","stack","PORT","RUNTIME_LOG_FILE","APP_LOG_FILE","HANDLER_PATH","TIMEOUT_MS","process","env","port","parseFloat","isNaN","runtimeLog","event","path","method","exit","timeoutMs","logger","appendFileSync","JSON","stringify","t","Date","toISOString","writeFileSync","log","logs","length","map","join","bind","serialize","val","Error","handler","currentRes","globalError","statusCode","end","console","args","error","import","then","imported","importedHandler","catch","server","createServer","req","res","startsWith","internalError","body","on","chunk","parsedUrl","URL","rawQueryString","search","slice","queryStringParameters","Object","fromEntries","URLSearchParams","decodeURIComponent","entries","sendRes","duration","headers","bodyLength","headerName","headerValue","setHeader","write","version","routeKey","rawPath","pathname","requestContext","accountId","http","userAgent","requestId","randomUUID","stage","timeEpoch","now","isBase64Encoded","startTs","context","getRemainingTimeInMillis","Promise","resolve","handlerRes","resBody","Buffer","from","listen","cleanup","close"],"sourceRoot":""}